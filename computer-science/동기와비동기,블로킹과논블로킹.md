## 동기와 비동기, 블로킹과 논블로킹

### 동기

- 현재 작업이 끝날때까지 다음 작업을 시작하지 않고 기다린다.
- 현재 작업이 끝나면 다음 작업을 시작한다.
- 작업 완료 여부를 계속 확인한다.
- 리턴이 값

### 비동기

- 현재 작업이 끝나지 않은 상태에서 다음 작업이 요청된다.
- 작업 완료 여부를 확인하지 않는다.
- 리턴이 콜백

![스크린샷 2022-04-06 오전 1.01.10.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/281b162f-42b4-4acb-8dda-2c7c57af087b/스크린샷_2022-04-06_오전_1.01.10.png)

### 블로킹

- 처리되어야하는 작업 하나가, 전체적인 작업 프로세스의 흐름을 막는다.
- 제어권을 넘겨주나, 계속 가지고 있는가? 에 초점
- 다른 작업에게 제어권을 넘겨주기 때문에 다시 제어권을 받을때까지 실행할 수 없다.

### 논블로킹

- 현재 작업이 계속해서 제어권을 가지고 있다.

### 조합

- 동기 + 블로킹
  - 리턴으로 값을 필요로 하면서, 제어권도 같이 받아야 다음 코드를 실행할 수 있다.
  - ex: 사용자 입력을 받고 입력값으로 코드 진행의 경우
- 동기 + 논블로킹
  - 리턴으로 값을 필요로 하지만, 제어권은 넘겨주지 않았기 때문에 현재 작업을 하면서 필요한 값을 계속 확인해야한다.
  - ex: 로딩 진행율을 계속해서 확인하는 경우
- 비동기 + 논블로킹
  - 리턴으로 콜백(Promise)를 받고, 제어권은 현재 작업이 가지고 있기 때문에 작업을 이어서 한다.
  - 후에 콜백의 리턴값을 반환받는다.
  - ex: 네트워크 요청(요청 한 뒤, 응답을 기다리지 않는다.)
- 비동기 + 블로킹
  - 리턴으로 콜백을 받지만 제어권도 함께 넘겨주어 콜백이 리턴할 때까지 현재 작업을 진행할 수 없다.
  - 사용하는 경우가 거의 없다.

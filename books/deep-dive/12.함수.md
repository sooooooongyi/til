## 12. 함수

> 함수... 선언하는 형태에 따라 다르게 작동한다! 😨

### 함수 리터럴

- 함수는 객체다.
- 함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자다.

**근데 함수 선언문은 몸체 밖에서 호출이 가능한걸요? 🧐**
이는 함수 리터럴의 중의적 문맥에서 나타나는 현상으로 문맥에 따라 `함수 선언문`, `함수 표현식`으로 해석될 수 있다.

💡 만약 `{}`가 단독으로 쓰인다면? -> 함수 선언문!
💡 만약 `{}`가 피연산자로 쓰인다면? -> 함수 표현식!

`함수 선언문`는 이름은 외부지만, 함수 이름과 동일한 식별자를 만들고 객체를 할당하기 때문에 몸체 밖에서 호출이 가능하다!

### 함수 선언문

```
function add(x, y) {
	return x + y;
}

```

- 이름을 생략할 수 없다.
- 표현식이 아닌 문이기 때문에 return 값은 undefined
- 함수 호이스팅이 발생한다.

### 함수 표현식

```
var f = function add(x, y) { // add 생략가능
	return x + y;
}

```

- 함수의 이름은 몸체 내에서만 사용할 수 있다.
- 함수 호이스팅이 아닌 변수(f) 호이스팅이 발생한다.

### Function 생성자 함수

```
var add = new Function('x', 'y', 'return x + y');

```

- 클로저를 생성하지 않는다.
- 사용을 지양한다.

### 화살표 함수

```
var add = (x, y) => x + y;

```

- 생성자 함수로 사용할 수 없다.
- prototype 프로퍼티가 없다.
- arguments 객체도 없다.
- 내부 동작도 간략화 되어있다.

### 퀴즈

1. 아래의 코드는 즉시 실행함수를 나타내는 코드다. 아래 코드가 오류가 나는 이유를 서술하세요!

```
(function bar() {
	console.log('bar)
})
bar();

```

1. parameter와 arguments의 차이점을 서술하세요!

### 함수 호출

- 매개변수 개수와 인수의 개수 일치 여부를 체크하지 않는다. (없으면 undefined)
- 매개변수는 3개 이하를 적극 추천
- 반환의 default 값은 undefined

### 참조에 의한 전달와 외부 상태의 변경

- 원시 타입의 값을 전달받은 경우, 변경 불가능하기 때문에 재할당한다.
- 객체 타입의 인수는 값이 복사되어 매개변수에 전달되기 때문에 함수 몸체에서 참조 값을 통해 객체를 변경할 경우 원본이 수정된다.
  - 이를 방지하기위해 객체를 불변 객체로 만들어사용한다.
  - 깊은 복사

### 다양한 형태의 함수

- 즉시 실행 함수
- 재귀 함수
- 중첩 함수
  - 중첩 함수는 외부 함수 내부에서만 호출할 수 있다.
- 콜백 함수
- 순수함수와 비순수함수

### 퀴즈

1. 위 함수를 조건에 맞게 수정하세요!

```
var count = 0;

function increase() {
	count ++
}

// 위 함수는 비순수함수로, 부수효과가 발생하고 있다.
// 이를 순수함수로 바꿔보세요! (순수 함수: 어떤 외부 상태에 의존하지 않고 변경하지도 않는 함수)

```

1. 다음 출력 결과를 고르세요!

```
var factorial = function foo(n) {
	return n*factorial(n-1);
}

console.log(factorial(5));

```

(1) 120
(2) Reference Error
(3) Uncaught RangeError
(4) undefined

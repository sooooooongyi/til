## 7. 연산자 📝

> nan에 데이고 다시 공부하는 연산자... 0.<

### 산술연산자

산술 연산자는 피연산자를 대상으로 수학적 계산을 수행해 새로운 숫자값을 만든다. 산술 연산이 불가능한 경우, **NaN**을 반환한다. 이항 산술 연산자, 단항 산술 연산자가 있다.

```
이항 산술 연산자 -> +, -, *, /
단항 산술 연산자 -> ++, --, +, -
(++, --는 부수효과가 있다!)

```

- `++`와 `-`는 부수효과가 있다.
- `+`는 문자열을 숫자 타입으로 변환한다. (할 수 없는 경우 NaN 반환)
- `+`는 연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다.
- ``는 부호를 반대로 바꾸면서 숫자 타입으로 변환한다.

### 할당 연산자

할당 연산자는 우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당한다.

### 비교 연산자

좌항과 우항의 피연산자를 비교한 다음 그 결과를 불리언 값으로 반환한다. `==`는 값이 같음을 나타내고 `===`는 값과 타입이 모두 같음을 의미한다.

### 삼항 조건 연산자

삼항 조건 연산자는 조건식의 평가 결과에 따라 반환할 값을 결정한다.

### 논리 연산자

논리 연산자는 우항과 좌항의 피연산자를 논리 연산한다.

- 논리 부정 연산자(!)는 항상 불리언 값을 반환한다.

### 쉼표 연산자

쉼표 연산자는 왼쪽 피연산자부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과를 반환한다.

### 그룹 연산자

소괄호로 피연산자를 감싸는 그룹 연산자는 자신의 피연산자인 표현식을 가장 먼저 평가한다.

### typeof 연산자

typeof 연산자는 피연산자의 데이터 타입을 문자열로 반환한다.

### 지수 연산자

피연산자 중 좌항을 밑으로 우항을 지수로 거듭제곱하여 숫자를 반환한다.

- 음수를 거듭제곱의 밑으로 계산하려면 괄호가 필요하다.

### 연산자의 우선 순위

> 달달달 외우기 쉽지않지만 알아두어야한다!

```
1) 괄호
2) new(...), [], (), ?.
3) new()
---------------------------------- 단항 산술 연산자
4) ++, -- (전위)
5) !, +, - ++, --, typeof, delete
---------------------------------- 이항 산술 연산자
6) **
7) *, /, %
8) +, -
9) <, <=, >, >=, in, instanceof
10) ==, !=, ===, !==
11) ??
12) &&
13) ||
14) ? ... : ...
15) =, +=, -= ...
16) ,

```

### 퀴즈

**1) 다음 값의 출력 결과는?**

```
console.log(1 + null);

// TypeError
// 1
// 2
// NaN

```

<details>
<summary>정답</summary>
<div markdown="1">

정답은 1!
null은 0으로 타입 변환됩니다.

</div>
</details>

**2) 다음 값의 출력 결과는?**

```
console.log(0 === -0);

// true
// false
// undefined

```

<details>
<summary>정답</summary>
<div markdown="1">

정답은 true!
`===`은 0과 -0을 구분하지 못합니다.
ES6에서 도입된 [Object.is](http://object.is/) 메서드는 이를 구분합니다.

</div>
</details>

**3) 다음 값의 출력 결과는?**

```
let a = 10;
let b = 20;

console.log(a++ * 3 + ++b);

// 51
// 50
// 53
// 54

```

<details>
<summary>정답</summary>
<div markdown="1">

정답은 54!
단항 연산자 > 이항 연산자 즉 a, b의 단항 연산이 끝난 후 곱하기가 실행됩니다.

</div>
</details>

**4) 다음 값의 출력 결과는?**

```
let i = 1;
let j = 1;
let k = 1;

++i || ++j && ++k)
console.log(i, j, k);

// 2 2 2
// 1 2 2
// 1 2 1
// 2 1 1

```

<details>
<summary>정답</summary>
<div markdown="1">

정답은 2 1 1!
우선, 바로 계산하지 않고 순서를 정하게 되는데 단항이 먼저, 그 후 논리 연산자가 계산됩니다.
++i || (++j && ++K) 식으로 바뀌게 됩니다. 논리 연산자는 왼쪽에서 오른쪽으로 식을 계산하게 되고 이때 ++값이 논리연산자보다 우선순위가 높기 때문에 연산이 됩니다. (i=2) 그리고 || 연산자에 의해 바로 리턴하기 때문에 j, k값은 바뀌지않습니다.

</div>
</details>

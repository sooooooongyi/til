## [chapter2] this가 이런거로군!

- this 바인딩 개념을 이해하기 위해선 호출부를 찾아봐야한다.
- 하지만 생각보다 진짜 호출부가 어디인지 모호할 때가 많다.
- 호출부 = 현재 실행 중인 함수 ‘직전'의 호출 코드 ‘내부'에 있다.
- 결국 규칙에 따라 this 바인딩이 되기 때문에 경우의 수를 잘 파악하자!

### 2.2.1 기본 바인딩

- 가장 평범한 함수 호출인 ‘단독 함수 실행’에 관한 규칙
- 기본 바인딩이 적용되어 this는 전역 객체를 참조한다.

### 2.2.2 암시적 바인딩

- 호출부에 콘텍스트 객체가 있는지, 즉 객체의 소유/포함 여부를 확인하는 것이다.
- 앞에 .이 붙는 경우를 의미하고 이때 함수 레퍼런스에 대한 콘텍스트 객체가 존재하기 때문에 암시적 바인딩 규칙에 따라 이 객체가 this에 바인딩된다.
- 하지만 암시적 소실이 되는 경우가 있어 this 바인딩을 헷갈릴 수 있다.
  - 함수를 인자로 전달할 때도, 콜백 함수로 사용할 때도 마찬가지!

### 2.2.3 명시적 바인딩

- call, apply 메소드 사용하기 → 직접 지정한 객체로 바인딩 하므로 ‘명시적 바인딩’이라 부른다.
- 객체 대신 원시값을 파라미터로 보내면 원시값에 대응되는 객체로 래핑된다. (new String() 등) → 박싱이라 부른다.
- 하지만 명시적 바인딩으론 소실되거나, 프레임워크가 덮어써버리는 문제를 해결할 수 없다.

**하드바인딩**

- 호출 함수 내부에 강제로 객체를 명시적으로 바인딩해 하드코딩할 수 있다.
- 재사용 가능한 헬퍼 함수 사용도 같은 패턴이다.

### 2.2.4 new 바인딩

- 함수 앞에 new를 붙이면 다음과 같은 일이 발생한다.
  1. 새 객체가 툭 만들어진다.
  2. 새로 생성된 객체의 [[Prototype]]이 연결된다.
  3. 새로 생성된 객체는 해당 함수 호출 시 this로 바인딩 된다.
  4. 이 함수가 자신의 또 다른 객체를 반환하지 않는 한 new와 함께 호출된 함수는 자동으로 새로 생성된 객체를 반환한다.

### 2.3 우선순위

1. new 바인딩
2. 명시적 바인딩
3. 암시적 바인딩
4. 기본값

### 2.4 바인딩 예외

- 특정 바인딩을 의도했는데 실제 기본 바인딩 규칙이 적용되는 예외 사례를 알아보자!

1. this 무시

- call, apply, bind 첫 번째 인자로 null, undefined를 넘겼을 때
- DMZ 객체를 사용하는 것이 좋다. (전혀 위임되지 않은 객체)

2. 간접 레퍼런스
3. 소프트바인딩

- 강제적 하드 바인딩이 다시 명시적, 암시적 바인딩하게끔 오버라이드가 안되기 때문에 고안된 유틸

### 2.5 어휘적 this

- 화살표 함수는 위 4가지 규칙을 따르지 않는다.
- 화살표 함수는 무조건 호출당시 어휘적 this를 따른다. (상위의 this에 따라, 또는 전역)
